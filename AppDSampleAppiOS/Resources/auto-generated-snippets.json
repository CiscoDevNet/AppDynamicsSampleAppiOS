[
{
"name": "App Start",
"content": "// Example: App Start\n//\n// (Must also include \"import ADEUMInstrumentation\"\n// above.) There is a simple option, or an advanced\n// option. You should choose one of the two. For\n// this example app, the simple option is commented\n// out just below, but you could change that.\n\n// Option 1: Simple option, no configuration object\n\n// Change this to the App Key provided for your account.\n// ADEumInstrumentation.initWithKey(\"ABC-DEF-GHI\")\n\n// Option 2: Advanced option, showing configuration\n\n// Change this to the App Key provided for your account.\nlet config = ADEumAgentConfiguration(appKey: \"ABC-DEF-GHI\")\n\n// Change this URL to the one provided for your account.\n// To try it locally with no collector, use localhost.\nconfig.collectorURL = \"http://localhost:9001\"\n\n// Change this URL to the one provided for your account.\nconfig.screenshotURL = \"http://localhost:9001\"\nconfig.loggingLevel = .all\nconfig.screenshotsEnabled = true // true is default, so this line is optional\nconfig.anrDetectionEnabled = true\nADEumInstrumentation.initWith(config)\n\n"
},
{
"name": "Excluded URL patterns",
"content": "// Example: Excluded URL patterns\n//\n// If needed, you can prevent instrumentation of\n// selected URLs. To do this, you would set the\n// value of the 'excludedUrlPatterns' property on\n// the ADEumAgentConfiguration instance at agent\n// initialization time, to hold a set of excluded\n// regular expression patterns that you specify.\n// Note that substrings are also matched, so the\n// pattern does not need to cover the entire URL\n// syntax from front to back:\n//\n// ... instantiate ADEumAgentConfiguration 'config'\n//     object (see App Start sample code) ...\n// let pattern1 = \"privatehost1\"\n// let pattern2 = \"privatehost2\"\n// let patternsToExclude = Set([pattern1, pattern2])\n// config.excludedUrlPatterns = patternsToExclude\n// ADEumInstrumentation.initWith(config)\n\n\n"
},
{
"name": "Periodic screenshots",
"content": "// Example: Periodic screenshots\n\n/*\n Periodic screenshots come automatically built in when you\n instrument an app with AppDynamics. Therefore, you don't\n have to add any code to get this feature!\n \n However, there is code you can use to control some\n aspects.\n \n For example, if you want to disable the feature\n completely, you can do so at initialization time by\n setting the screenshotsEnabled flag to false in your\n application(didFinishLaunchingWithOptions:) function:\n \n let config = ADEumAgentConfiguration(appKey: \"ABC-DEF-GHI\")\n config.screenshotsEnabled = false\n ... other configuration settings ...\n ADEumInstrumentation.initWith(config)\n\n Alternatively, if you have left the feature enabled,\n you can disable the feature temporarily as needed.\n \n For example, you might want to disable periodic\n screenshots when you know that your app may be about\n to display sensitive data.\n \n To temporarily block periodic screenshots, call the\n blockScreenshots() function. This can later be\n undone by calling unblockScreenshots():\n \n import ADEUMInstrumentation\n ...\n ADEumInstrumentation.blockScreenshots()\n // show sensitive data\n ...\n // sensitive data no longer shown\n ADEumInstrumentation.unblockScreenshots()\n \n */\n\n"
},
{
"name": "ANR",
"content": "// Example: ANR\n\n// To enable Application Not Responding detection and\n// reporting, you must set the anrDetectionEnabled\n// property of the ADEumAgentConfiguration instance\n// object to true prior to initializing the agent with\n// the configuration object:\n/*\n let config = ADEumAgentConfiguration(appKey: \"<YOUR-APP-KEY>\")\n config.anrDetectionEnabled = true\n ... do additional configuration settings ...\n ADEumInstrumentation.initWith(config)\n */\n// You can also ask for stack traces showing execution\n// context in proximity to the ANR, with:\n// config.anrStackTraceEnabled = true\n// However, there can be no guarantee that these stack\n// traces directly correspond to the cause of the ANR,\n// so their utility is limited and turning them on is\n// not recommended in most cases.\n\n// To force an ANR, such as for testing, invoke a\n// sleep on the main thread as in this example:\n/*\nDispatchQueue.main.async {\n    Thread.sleep(forTimeInterval: 10.0)\n}\n */\n// Of course, this is something you would only do for\n// testing, debugging, or, as we are doing here, for\n// demonstrating ANR functionality. It should\n// generally not be done in a shipping app.\n\n// Once enabled, ANR detection works without any\n// additional code. Also, once enabled, it can be\n// controlled (turned off and back on, timeout value\n// updated, and stack trace option turned on or off)\n// on a per-app key basis through server side\n// configuration.\n\n"
},
{
"name": "Reporting selected errors",
"content": "// Example: Reporting selected errors\n\n// Here we conduct an operation that we know\n// will fail (attempting to read the contents\n// of a directory that does not exist), in\n// order to demonstrate how to use the\n// reportError() feature.\n\nlet fm = FileManager.default\ndo {\n    let path = \"/no-such-path\"\n    // normally we would do let foo = fm.contentsOf...\n    // but here we are just going for the error.\n    try fm.contentsOfDirectory(atPath: path)\n} catch let error {\n    \n    // Instrument the error\n    ADEumInstrumentation.reportError(error, withSeverity: .warning)\n    \n    let message = \"Error: \\(error.localizedDescription)\"\n    label.text = message\n    print(message)\n}\n\n"
},
{
"name": "Start next session",
"content": "// Example: Start next session\n\n// Import may be needed for use:\n// import ADEUMInstrumentation\n\n// Sessions are ended automatically after a\n// period of inactivity. However, they can also\n// be ended at any time by invoking this optional\n// method, which forces an end to the current\n// session.\n\n// You can use this to mark the end of an\n// interaction flow of some significance to\n// your app, and, by implication, the\n// beginning of a new flow. Please read the\n// comments in the public interface (header)\n// file ADEumInstrumentation_interfaces.h\n// for more details about Sessions.\n\n// Note that the case for the prefix of the\n// class here (ADEum) differs from the case\n// (ADEUM) for the header import statement.\n\nADEumInstrumentation.startNextSession()\n\n\n"
},
{
"name": "Leaving a breadcrumb",
"content": "// Example: Leaving a breadcrumb\n\n// Import may be needed for use:\n// import ADEUMInstrumentation\n//\n// Note that the case for the prefix of the class\n// here (ADEum) differs from the case (ADEUM) for\n// for the header import statement.\n//\n// The breadcrumb value can be any string of your\n// choosing, including strings dynamically chosen\n// or built at runtime based on state in your app.\n//\n// A crashes-only breadcrumb is the default, and\n// is preferred because it avoids needlessly\n// polluting your cloud data with redundant string\n// values when there are no crashes.\n//\n// Crashes-only breadcrumbs are only sent up to\n// the cloud if the prior run of the app crashed.\n//\n// To make best use of crashes-only breadcrumbs,\n// place them in code leading up to places where\n// crashes have been detected, or are suspected.\n// This way you can then inspect any such\n// breadcrumbs that show up, to learn which code\n// paths were followed, and which which values were\n// present, prior to the crash you are debugging.\n\n// Leave a breadcrumb with value \"sample1\", which\n// only gets sent (next run) if there is a crash.\nADEumInstrumentation.leaveBreadcrumb(\"sample1\")\n\n// Alternatively, you can create breadcrumbs that\n// always get sent, not only after crashes, but\n// also when any session ends, as shown below:\n\n// Leave a breadcrumb with the value \"sample2\",\n// which gets sent upon end of session or after\n// any crash.\nADEumInstrumentation.leaveBreadcrumb(\"sample2\", mode:\n    ADEumBreadcrumbVisibility.crashesAndSessions)\n\n\n"
},
{
"name": "Instrumenting network calls",
"content": "// Example: Instrumenting network calls\n//\n// Network calls, whether successful or not, are\n// instrumented automatically without you adding any\n// code! So there is nothing to show here. There are\n// some advanced features that do require code, and\n// these are covered elsewhere:\n//\n// 1. Server Correlation Headers (see documentation at\n// https://docs.appdynamics.com/21.9/en/end-user-monitoring/mobile-real-user-monitoring/correlate-business-transactions-for-mobile-rum)\n//\n// 2. Excluded URL Patterns (prevent instrumentation\n//    of URLs matching regular expressions you\n//    specify)\n\n"
},
{
"name": "Network request timeout",
"content": "// Example: Network request timeout\n//\n// No user code needed!\n//\n// As long as you have integrated the AppDynamics\n// agent into your app, you will get instrumentation\n// of network call events including timeouts by\n// default, without adding any additional code.\n//\n// When running an instrumented app such as this\n// one under Xcode, after a networking call has\n// completed, if you wish you can look at the JSON\n// instrumentation packets that appear in the Xcode\n// console to verify for yourself that the agent\n// has captured the networking activity as expected.\n\n"
},
{
"name": "View Controller tracking",
"content": "// Example: View Controller tracking\n//\n// No user code needed!\n//\n// Transitions to and from different view\n// controller classes will be tracked and\n// reported along with the name of the\n// involved view controller class.\n\n"
},
{
"name": "Crash reporting",
"content": "// Example: Crash reporting\n\n// Note that you need not add any code in order\n// to get crash reporting. As long as you have\n// initialized the agent (covered in the App\n// Start sample code) then you will have crash\n// reporting on by default.\n\n// (It is also possible to instead turn crash\n// reporting off, by setting the public\n// crashReportingEnabled flag of the configuration\n// object to false, but you would do this at agent\n// initialization time, typically in the\n// AppDelegate. We don't want to do that here in\n// this demonstration, so we have commented it out):\n\n/*\n// How to initialize with crash reporting off:\nlet config = ADEumAgentConfiguration(appKey: \"<YOUR-APP-KEY>\")\nconfig.crashReportingEnabled = false\n ...\nADEumInstrumentation.initWith(config)\n*/\n \n// After a crash, the agent will gather the crash\n// data and forward it to the cloud the next time\n// the user launches the app.\n\n// Here, for demonstration purposes, we have\n// intentionally added a call to fatalError() to\n// invoke a crash.\n\n// Obviously you would not do this in your shipping\n// production app!\n\nfatalError()\n\n\n"
}]
